// -----------
// usage:
// webppl myscratch.wppl --require webppl-json


// core data structure: cluster.
// looks like this:
// {
// "ere": [
//     "E779987.00064",
//     "V779987.00022"
// ],
// "statements": [
//     202,
//     200,
//     203,
//     206,
//     188
// ],
// "corefacets": {
//     "?crash_target": "E779987.00064",
//     "?crash_event": "V779987.00022"
// },
// "coreconstraints": [
//     [
//      "?crash_event",
//      "Conflict.Attack_Attacker",
//      "?crash_attacker"
//     ],
//     [
//      "?crash_event",
//      "Conflict.Attack_Instrument",
//      "?crash_instrument"
//     ],
//     [
//      "?crash_event",
//      "Conflict.Attack_Place",
//      "?crash_place"
//     ]
//    ],
//    "candidates": [
//     195,
//     201,
//     175,
//     177,
//     179,
//     212,
//     182,
//     184
// ]
// }


//------------------------------------------------
// Data generated by generate_wppl.py
//------------------------------------------------

var jsonData = json.read('aidagraph.json');

//------------------------------------------------
// General functions
//------------------------------------------------

// remove duplicates in an array
var myUnique = function(arr) {
    return reduce(function(index, acc) {
	return arr.indexOf( arr[ index ] ) < index ? acc : [ arr[index ]].concat(acc)
    }, [ ],  _.range(arr.length))
}

// add a second array to a first one while omitting duplicates in the 2nd array
var myAddUnique = function(arr1, arr2) {
    return reduce( function(entry, acc) {
	return arr1.indexOf(entry) > -1 ? acc : [ entry ].concat(acc)
    }, arr1, arr2)
}

// return all members in array1 that are not in array2
var mySetDiff = function(arr1, arr2) {
    return filter(
	function(entry) {
	    return arr2.indexOf(entry) == -1
	}, arr1)
}

// intersection of two arrays
var myIntersection = function(array1, array2) {
    return filter(
	function(e) {
	    return array2.indexOf(e) > -1
	},
	array1)
}
	

// return array minus all elements that are equal to elt
var myArrayMinusElt = function(somearray, elt) {
    return filter(function(e) { return e != elt }, somearray)
}


//-------------------------------
// Proximity measures
//-----

// candidate proximity: how close is the candidate to the cluster?
// cluster: structure as above
// candidate: statement index
var candidateProximity = function(cluster, candidate) {
    return averageProximity(cluster, candidate)
}


// candidate proximity as proximity to a random cluster member
var randomMemberProximity = function(cluster, candidate) {
    var randomMember = uniformDraw(cluster["statements"])
    return jsonData["statementProximity"][randomMember][candidate]
}

// candidate proximity as average proximity:
// 1/clustersize sum_{cluster member i} proximity(i, candidate)
// when proximities are random walk probabilities, this is the probability
// of ending up at candidate when taking a one-step random walk from any cluster member.
var averageProximity = function(cluster, candidate) {
    return sum(map(function(i) { return jsonData["statementProximity"][i][candidate] },
		  cluster["statements"]))  / cluster["statements"].length
}

//-------------------------------
// Helper functions
//-----


// take a list of statement indices and map them to statement labels
var statementIndicesToLabels = function(stmtIxList) {
    return map(
	function(stmtIx) {
	    return jsonData.statements[stmtIx]
	},
	stmtIxList)
}

// take a list of statement indices and map them to a list of statement entries
var statementIndicesToEntries = function(stmtIxList) {
    return map(
	function(stmtIx) {
	    return jsonData.theGraph[ jsonData.statements[stmtIx] ]
	},
	stmtIxList)
}

// find all EREs that are mentioned in a given statement
// statementIndex: index of a statement
var ereInStatement = function(statementIndex) {
    // find the statement going with this index in "statements", then
    // find the entry for the statement in "theGraph"
    var statementEntry = jsonData.theGraph[ jsonData.statements[statementIndex] ]
    
    // return subject and objects for this entry
    // that again have an entry in "theGraph" and have an ERE type
    return myUnique(
	filter(
	    function(entry) {
		return _.has(jsonData.theGraph, entry) &&
		    (jsonData.theGraph[entry].type == "Entity" ||
		     jsonData.theGraph[entry].type == "Event" ||
		     jsonData.theGraph[entry].type == "Relation")
	    },
	    map(
		function(role) {
		    return statementEntry[role] },
		["subject", "object"]
	    )
	)
    )
}


// given a list of ERE names and a list of statements,
// find the statements adjacent to each ERE,
// and form the union of all those with the old statements
var addStatementsFromEre = function(oldStatements, EreList) {
    return reduce(
	function(ere, acc1) {
	    return reduce(
		function(stmt, acc2) {
		    return acc2.indexOf(stmt) > -1 ? acc2 : acc2.concat( stmt )
		},
		acc1, jsonData.theGraph[ere].adjacent)    
	},
	oldStatements, EreList)
}

//-------------------------------
// Model
// This is one incremental sample for the particle filter
//-----

// compute new cluster when the candidate is added
var extendAddCandidate = function(cluster, candidate) {
    var addEre = mySetDiff( ereInStatement(candidate), cluster["ere"])
    var newStatements = cluster["statements"].concat(candidate)
    var newConsidered = cluster["considered"].concat(candidate)
    
    // candidates: old candidates plus statements adjacent to the new EREs,
    // minus statements already considered
    var newCandidates = mySetDiff(
	addStatementsFromEre(
	    cluster["candidates"], addEre),
	newConsidered)

    // display("adding")
    // display(["newEre", addEre])
    // display(["stmt", mySetDiff(newStatements, cluster["statements"])])
    // display(["cand", mySetDiff(newCandidates, cluster["candidates"])])
    // display(["stmt CAP cand", myIntersection(newStatements, newCandidates)])
    
    return {
	ere : cluster["ere"].concat( addEre ),
	statements : newStatements,
	corefacets : cluster["corefacets"],
	coreconstraints : cluster["coreconstraints"],
	candidates : newCandidates,
	considered: newConsidered
    }	    
}

// compute new cluster when the candidate is not added
var extendDropCandidate = function(cluster, candidate) {
    var otherCandidates = myArrayMinusElt(cluster["candidates"], candidate)
    var newConsidered = cluster["considered"].concat(candidate)

    // display("not adding")
    // display(["cand", otherCandidates])
    // display(["stmt CAP cand", myIntersection(cluster["statements"], otherCandidates)])
    
	    
    return {
	ere : cluster["ere"],
	statements : cluster["statements"],
	corefacets : cluster["corefacets"],
	coreconstraints : cluster["coreconstraints"],
	candidates : otherCandidates,
	considered: newConsidered
    }
}



// choose a random statement to extend the cluster by.
// flip a coin to see if it should be added to the cluster, or dropped.
//
// cluster: structure 
// candidates: list of indices of datapoints that can potentially be added to the cluster
// muTau, sigmaTau: parameters of the threshold distribution
var extendCluster = function(cluster, thresholdParameters) {

    if (cluster["candidates"].length == 0) {
	// we have considered all candidates, the cluster is finished.
	// returns the statements of the cluster
	return cluster["statements"];
    } else {
	// consider a candidate
	var candidate = uniformDraw(cluster["candidates"])
	    
	// choose a threshold for it
	var tau = gamma( thresholdParameters )

	// choose whether it is a member
	var isMember = flip()

	// display(["candidate", candidate, jsonData["statements"][candidate]])
	// display(["isMember", isMember, "tau", tau, "proximity", candidateProximity(cluster, candidate)])
    

    	// The candidate needs to be on the right side of threshold tau
    	if (isMember) {
    	    condition( candidateProximity(cluster, candidate) > tau)

    	    return extendCluster(extendAddCandidate(cluster, candidate), thresholdParameters)
	    
    	} else {
    	    condition( candidateProximity( cluster, candidate) < tau)
	    
    	    return extendCluster(extendDropCandidate(cluster, candidate), thresholdParameters)
    	}
    }
}

		  

//-------------------------------
// Inference
//-----



var model = function(clusterSeed) {
    var shapeTau = 5.0
    var scaleTau = 0.01
    // display("parameters")
    // display([shapeTau, scaleTau])
    
    return sort(statementIndicesToLabels(extendCluster(clusterSeed, {shape: shapeTau, scale: scaleTau})))
}
			  

var Experiment = function () {
    // cluster seed:
    // draw from entry points,
    // then add the list of considered statements: added plus non-added. currently,
    // this is simply the list of statements in the seed.
    var clusterSeedIncomplete =  uniformDraw(jsonData["entrypoints"])
    var clusterSeed = _.extend(clusterSeedIncomplete, { considered : clusterSeedIncomplete["statements"]} )
    
    // display("starting point")
    // display(clusterSeed)


    var result = Infer( { method : "SMC", particles : 1000 }, function() {
	return model(clusterSeed)
    })

    return result
}

//-------------------------------
var result = Experiment()

json.write('aidaresult.json', result);
